[
  {
    "id": "V1",
    "name": "Encoding and Sanitization",
    "objective": "<p>This chapter addresses the most common web application security weaknesses related to the unsafe processing of untrusted data. Such weaknesses can result in various technical vulnerabilities, where untrusted data is interpreted according to the syntax rules of the relevant interpreter. For modern web applications, it is always best to use safer APIs, such as parameterized queries, auto-escaping, or templating frameworks. Otherwise, carefully performed output encoding, escaping, or sanitization becomes critical to the application's security. Input validation serves as a defense-in-depth mechanism to protect against unexpected or dangerous content. However, since its primary purpose is to ensure that incoming content matches functional and business expectations, requirements related to this can be found in the \"Validation and Business Logic\" chapter.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Input Validation Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Cross Site Scripting Prevention</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">SQL Injection Prevention</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Injection Prevention</a></li></ul></div>"
  },
  {
    "id": "V2",
    "name": "Validation and Business Logic",
    "objective": "<p>This chapter aims to ensure that a verified application meets the following high-level goals:</p><ul><li>Input received by the application matches business or functional expectations.</li><li>The business logic flow is sequential, processed in order, and cannot be bypassed.</li><li>Business logic includes limits and controls to detect and prevent automated attacks, such as continuous small funds transfers or adding a million friends one at a time.</li><li>High-value business logic flows have considered abuse cases and malicious actors, and have protections against spoofing, tampering, information disclosure, and elevation of privilege attacks.</li></ul><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Input Validation Cheat Sheet</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/10-Business_Logic_Testing/\" target=\"_blank\" rel=\"noopener\">Business Logic Testing Guide</a></li></ul></div>"
  },
  {
    "id": "V3",
    "name": "Web Frontend Security",
    "objective": "<p>This category focuses on requirements designed to protect against attacks executed via a web frontend. These requirements do not apply to machine-to-machine solutions.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Content Security Policy Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Clickjacking Defense</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">DOM based XSS Prevention</a></li></ul></div>"
  },
  {
    "id": "V4",
    "name": "API and Web Service",
    "objective": "<p>Several considerations apply specifically to applications that expose APIs for use by web browsers or other consumers (commonly using JSON, XML, or GraphQL). This chapter covers the relevant security configurations and mechanisms that should be applied. Note that authentication, session management, and input validation concerns from other chapters also apply to APIs, so this chapter cannot be taken out of context or tested in isolation.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">REST Security Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">GraphQL Cheat Sheet</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/\" target=\"_blank\" rel=\"noopener\">Web Service Testing Guide</a></li></ul></div>"
  },
  {
    "id": "V5",
    "name": "File Handling",
    "objective": "<p>The use of files can present a variety of risks to the application, including denial of service, unauthorized access, and storage exhaustion. This chapter includes requirements to address these risks.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">File Upload Cheat Sheet</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/10-Business_Logic_Testing/09-Test_Upload_of_Malicious_Files\" target=\"_blank\" rel=\"noopener\">File Upload Testing</a></li></ul></div>"
  },
  {
    "id": "V6",
    "name": "Authentication",
    "objective": "<p>Authentication is the process of establishing or confirming the authenticity of an individual or device.</p><p>It involves verifying claims made by a person or about a device, ensuring resistance to impersonation, and preventing the recovery or interception of passwords.</p><p><a href=\"https://pages.nist.gov/800-63-3/\" target=\"_blank\" rel=\"noopener\">NIST SP 800-63</a> is a modern, evidence-based standard that is valuable for organizations worldwide, but is particularly relevant to US agencies and those interacting with US agencies.</p><p>While many of the requirements in this chapter are based on the second section of the standard (known as NIST SP 800-63B \"Digital Identity Guidelines-Authentication and Lifecycle Management\"), the chapter focuses on common threats and frequently exploited authentication weaknesses.</p><p>It does not attempt to comprehensively cover every point in the standard.</p><p>For cases where full NIST SP 800-63 compliance is necessary, please refer to NIST SP 800-63.</p><p>Additionally, NIST SP 800-63 terminology may sometimes differ, and this chapter often uses more commonly understood terminology to improve clarity.</p><p>A common feature of more advanced applications is the ability to adapt authentication stages required based on various risk factors.</p><p>This feature is covered in the \"Authorization\" chapter, since these mechanisms also need to be considered for authorization decisions.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Authentication Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Password Storage Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Forgot Password Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Multifactor Authentication</a></li></ul></div>"
  },
  {
    "id": "V7",
    "name": "Session Management",
    "objective": "<p>Session management mechanisms allow applications to correlate user and device interactions over time, even when using stateless communication protocols (such as HTTP). Modern applications may use multiple session tokens with distinct characteristics and purposes. A secure session management system is one that prevents attackers from obtaining, utilizing, or otherwise abusing a victim's session. Applications maintaining sessions must ensure that the following high-level session management requirements are met:</p><ul><li>Sessions are unique to each individual and cannot be guessed or shared.</li><li>Sessions are invalidated when no longer required and are timed out during periods of inactivity. Many of the requirements in this chapter relate to selected <a href=\"https://pages.nist.gov/800-63-4/\" target=\"_blank\" rel=\"noopener\">NIST SP 800-63 Digital Identity Guidelines</a> controls, focusing on common threats and commonly exploited authentication weaknesses. Note that requirements for specific implementation details of certain session management mechanisms can be found elsewhere:</li><li>HTTP Cookies are a common mechanism for securing session tokens. Specific security requirements for cookies can be found in the \"Web Frontend Security\" chapter.</li><li>Self-contained tokens are frequently used as a way of maintaining sessions. Specific security requirements can be found in the \"Self-contained Tokens\" chapter.</li></ul><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Session Management Cheat Sheet</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/\" target=\"_blank\" rel=\"noopener\">Session Management Testing</a></li></ul></div>"
  },
  {
    "id": "V8",
    "name": "Authorization",
    "objective": "<p>Authorization ensures that access is granted only to permitted consumers (users, servers, and other clients). To enforce the Principle of Least Privilege (POLP), verified applications must meet the following high-level requirements:</p><ul><li>Document authorization rules, including decision-making factors and environmental contexts.</li><li>Consumers should have access only to resources permitted by their defined entitlements.</li></ul><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Authorization Cheat Sheet</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/\" target=\"_blank\" rel=\"noopener\">Access Control Testing</a></li></ul></div>"
  },
  {
    "id": "V9",
    "name": "Self-contained Tokens",
    "objective": "<p>The concept of a self-contained token is mentioned in the original RFC 6749 OAuth 2.0 from 2012.</p><p>It refers to a token containing data or claims on which a receiving service will rely to make security decisions.</p><p>This should be differentiated from a simple token containing only an identifier, which a receiving service uses to look up data locally.</p><p>The most common examples of self-contained tokens are JSON Web Tokens (JWTs) and SAML assertions.</p><p>The use of self-contained tokens has become very widespread, even outside of OAuth and OIDC.</p><p>At the same time, the security of this mechanism relies on the ability to validate the integrity of the token and to ensure that the token is valid for a particular context.</p><p>There are many pitfalls with this process, and this chapter provides specific details of the mechanisms that applications should have in place to prevent them.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">JSON Web Token Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">JWT Security Best Practices</a></li></ul></div>"
  },
  {
    "id": "V10",
    "name": "OAuth and OIDC",
    "objective": "<p>OAuth2 (referred to as OAuth in this chapter) is an industry-standard framework for delegated authorization. For example, using OAuth, a client application can obtain access to APIs (server resources) on a user's behalf, provided the user has authorized the client application to do so. By itself, OAuth is not designed for user authentication. The OpenID Connect (OIDC) framework extends OAuth by adding a user identity layer on top of OAuth. OIDC provides support for features including standardized user information, Single Sign-On (SSO), and session management. As OIDC is an extension of OAuth, the OAuth requirements in this chapter also apply to OIDC. The following roles are defined in OAuth:</p><ul><li>The OAuth client is the application that attempts to obtain access to server resources (e.g., by calling an API using the issued access token). The OAuth client is often a server-side application.</li><li>A confidential client is a client capable of maintaining the confidentiality of the credentials it uses to authenticate itself with the authorization server.</li><li>A public client is not capable of maintaining the confidentiality of credentials for authenticating with the authorization server. Therefore, instead of authenticating itself (e.g., using 'client_id' and 'client_secret' parameters), it only identifies itself (using a 'client_id' parameter).</li><li>The OAuth resource server (RS) is the server API exposing resources to OAuth clients.</li><li>The OAuth authorization server (AS) is a server application that issues access tokens to OAuth clients. These access tokens allow OAuth clients to access RS resources, either on behalf of an end-user or on the OAuth client's own behalf. The AS is often a separate application, but (if appropriate) it may be integrated into a suitable RS.</li><li>The resource owner (RO) is the end-user who authorizes OAuth clients to obtain limited access to resources hosted on the resource server on their behalf. The resource owner consents to this delegated authorization by interacting with the authorization server. The following roles are defined in OIDC:</li><li>The relying party (RP) is the client application requesting end-user authentication through the OpenID Provider. It assumes the role of an OAuth client.</li><li>The OpenID Provider (OP) is an OAuth AS that is capable of authenticating the end-user and provides OIDC claims to an RP. The OP may be the identity provider (IdP), but in federated scenarios, the OP and the identity provider (where the end-user authenticates) may be different server applications. OAuth and OIDC were initially designed for third-party applications. Today, they are often used by first-party applications as well. However, when used in first-party scenarios, such as authentication and session management, the protocol adds some complexity, which may introduce new security challenges. OAuth and OIDC can be used for many types of applications, but the focus for ASVS and the requirements in this chapter is on web applications and APIs. Since OAuth and OIDC can be considered logic on top of web technologies, general requirements from other chapters always apply, and this chapter cannot be taken out of context. This chapter addresses best current practices for OAuth2 and OIDC aligned with specifications found at <https://oauth.net/2/> and <https://openid.net/developers/specs/>. Even if RFCs are considered mature, they are updated frequently. Thus, it is important to align with the latest versions when applying the requirements in this chapter. See the references section for more details. Given the complexity of the area, it is vitally important for a secure OAuth or OIDC solution to use well-known industry-standard authorization servers and apply the recommended security configuration. Terminology used in this chapter aligns with OAuth RFCs and OIDC specifications, but note that OIDC terminology is only used for OIDC-specific requirements; otherwise, OAuth terminology is used. In the context of OAuth and OIDC, the term \"token\" in this chapter refers to:</li><li>Access tokens, which shall only be consumed by the RS and can either be reference tokens that are validated using introspection or self-contained tokens that are validated using some key material.</li><li>Refresh tokens, which shall only be consumed by the authorization server that issued the token.</li><li>OIDC ID Tokens, which shall only be consumed by the client that triggered the authorization flow. The risk levels for some of the requirements in this chapter depend on whether the client is a confidential client or regarded as a public client. Since using strong client authentication mitigates many attack vectors, a few requirements might be relaxed when using a confidential client for L1 applications.</li></ul><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">OAuth 2.0 Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">SAML Security Cheat Sheet</a></li></ul></div>"
  },
  {
    "id": "V11",
    "name": "Cryptography",
    "objective": "<p>The objective of this chapter is to define best practices for the general use of cryptography, as well as to instill a fundamental understanding of cryptographic principles and inspire a shift toward more resilient and modern approaches. It encourages the following:</p><ul><li>Implementing robust cryptographic systems that fail securely, adapt to evolving threats, and are future-proof.</li><li>Utilizing cryptographic mechanisms that are both secure and aligned with industry best practices.</li><li>Maintaining a secure cryptographic key management system with appropriate access controls and auditing.</li><li>Regularly evaluating the cryptographic landscape to assess new risks and adapt algorithms accordingly.</li><li>Discovering and managing cryptographic use cases throughout the application's lifecycle to ensure that all cryptographic assets are accounted for and secured. In addition to outlining general principles and best practices, this document also provides more in-depth technical information about the requirements in Appendix C - Cryptography Standards. This includes algorithms and modes that are considered \"approved\" for the purposes of the requirements in this chapter. Requirements that use cryptography to solve a separate problem, such as secrets management or communications security, will be in different parts of the standard.</li></ul><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Cryptographic Storage Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Key Management Cheat Sheet</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/\" target=\"_blank\" rel=\"noopener\">Cryptography Testing</a></li></ul></div>"
  },
  {
    "id": "V12",
    "name": "Secure Communication",
    "objective": "<p>This chapter includes requirements related to the specific mechanisms that should be in place to protect data in transit, both between an end-user client and a backend service, as well as between internal and backend services. The general concepts promoted by this chapter include:</p><ul><li>Ensuring that communications are encrypted externally, and ideally internally as well.</li><li>Configuring encryption mechanisms using the latest guidance, including preferred algorithms and ciphers.</li><li>Ensuring that communications are not being intercepted by unauthorized parties through the use of signed certificates. In addition to outlining general principles and best practices, the ASVS also provides more in-depth technical information about cryptographic strength in Appendix C - Cryptography Standards.</li></ul><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Transport Layer Security Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">TLS Cipher String Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">HTTP Strict Transport Security</a></li></ul></div>"
  },
  {
    "id": "V13",
    "name": "Configuration",
    "objective": "<p>The application's default configuration must be secure for use on the Internet. This chapter provides guidance on the various configurations necessary to achieve this, including those applied during development, build, and deployment. Topics covered include preventing data leakage, securely managing communication between components, and protecting secrets.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Docker Security Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Kubernetes_Security_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Kubernetes Security Cheat Sheet</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/\" target=\"_blank\" rel=\"noopener\">Configuration Testing</a></li></ul></div>"
  },
  {
    "id": "V14",
    "name": "Data Protection",
    "objective": "<p>Applications cannot account for all usage patterns and user behaviors, and should therefore implement controls to limit unauthorized access to sensitive data on client devices. This chapter includes requirements related to defining what data needs to be protected, how it should be protected, and specific mechanisms to implement or pitfalls to avoid. Another consideration for data protection is bulk extraction, modification, or excessive usage. Each system's requirements are likely to be very different, so determining what is \"abnormal\" must consider the threat model and business risk. From an ASVS perspective, detecting these issues is handled in the \"Security Logging and Error Handling\" chapter, and setting limits is handled in the \"Validation and Business Logic\" chapter.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Cryptographic Storage Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">User Privacy Protection</a></li></ul></div>"
  },
  {
    "id": "V15",
    "name": "Secure Coding and Architecture",
    "objective": "<p>Many ASVS requirements either relate to a particular area of security, such as authentication or authorization, or pertain to a particular type of application functionality, such as logging or file handling. This chapter provides general security requirements to consider when designing and developing applications. These requirements focus not only on clean architecture and code quality but also on specific architecture and coding practices necessary for application security.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/\" target=\"_blank\" rel=\"noopener\">Secure Coding Practices</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Threat Modeling Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Abuse Case Cheat Sheet</a></li></ul></div>"
  },
  {
    "id": "V16",
    "name": "Security Logging and Error Handling",
    "objective": "<p>Security logs are distinct from error or performance logs and are used to record security-relevant events such as authentication decisions, access control decisions, and attempts to bypass security controls, such as input validation or business logic validation. Their purpose is to support detection, response, and investigation by providing high-signal, structured data for analysis tools like SIEMs. Logs should not include sensitive personal data unless legally required, and any logged data must be protected as a high-value asset. Logging must not compromise privacy or system security. Applications must also fail securely, avoiding unnecessary disclosure or disruption. For detailed implementation guidance, refer to the OWASP Cheat Sheets in the references section.</p><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Logging Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Error Handling Cheat Sheet</a></li><li><a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Logging_Vocabulary_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\">Logging Vocabulary Cheat Sheet</a></li></ul></div>"
  },
  {
    "id": "V17",
    "name": "WebRTC",
    "objective": "<p>Web Real-Time Communication (WebRTC) enables real-time voice, video, and data exchange in modern applications. As adoption increases, securing WebRTC infrastructure becomes critical. This section provides security requirements for stakeholders who develop, host, or integrate WebRTC systems. The WebRTC market can be broadly categorized into three segments: 1. Product Developers: Proprietary and open-source vendors that create and supply WebRTC products and solutions. Their focus is on developing robust and secure WebRTC technologies that can be used by others. 2. Communication Platforms as a Service (CPaaS): Providers that offer APIs, SDKs, and the necessary infrastructure or platforms to enable WebRTC functionalities. CPaaS providers may use products from the first category or develop their own WebRTC software to offer these services. 3. Service Providers: Organizations that leverage products from product developers or CPaaS providers, or develop their own WebRTC solutions. They create and implement applications for online conferencing, healthcare, e-learning, and other domains where real-time communication is crucial. The security requirements outlined here are primarily focused on Product Developers, CPaaS, and Service Providers who:</p><ul><li>Utilize open-source solutions to build their WebRTC applications.</li><li>Use commercial WebRTC products as part of their infrastructure.</li><li>Use internally developed WebRTC solutions or integrate various components into a cohesive service offering. It is important to note that these security requirements do not apply to developers who exclusively use SDKs and APIs provided by CPaaS vendors. For such developers, the CPaaS providers are typically responsible for most of the underlying security concerns within their platforms, and a generic security standard like ASVS may not fully address their needs.</li></ul><div class=\"objective-references\"><strong>References:</strong><ul><li><a href=\"https://owasp.org/www-community/vulnerabilities/WebRTC\" target=\"_blank\" rel=\"noopener\">WebRTC Security</a></li><li><a href=\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client-side_Testing/\" target=\"_blank\" rel=\"noopener\">Client-Side Testing</a></li></ul></div>"
  }
]